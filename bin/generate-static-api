#!/usr/bin/php
<?php declare(strict_types=1);

use Acelot\AutoMapper\Api;
use Acelot\AutoMapper\Integrations;
use PhpParser\Comment\Doc;
use PhpParser\Node;
use PhpParser\Node\Arg;
use PhpParser\Node\Expr\Array_;
use PhpParser\Node\Expr\ArrayDimFetch;
use PhpParser\Node\Expr\Assign;
use PhpParser\Node\Expr\BooleanNot;
use PhpParser\Node\Expr\ClassConstFetch;
use PhpParser\Node\Expr\Isset_;
use PhpParser\Node\Expr\MethodCall;
use PhpParser\Node\Expr\New_;
use PhpParser\Node\Expr\StaticCall;
use PhpParser\Node\Expr\StaticPropertyFetch;
use PhpParser\Node\Expr\Variable;
use PhpParser\Node\Identifier;
use PhpParser\Node\Name;
use PhpParser\Node\Param;
use PhpParser\Node\Scalar\LNumber;
use PhpParser\Node\Stmt\Class_;
use PhpParser\Node\Stmt\ClassMethod;
use PhpParser\Node\Stmt\Declare_;
use PhpParser\Node\Stmt\DeclareDeclare;
use PhpParser\Node\Stmt\Expression;
use PhpParser\Node\Stmt\GroupUse;
use PhpParser\Node\Stmt\If_;
use PhpParser\Node\Stmt\Namespace_;
use PhpParser\Node\Stmt\Property;
use PhpParser\Node\Stmt\PropertyProperty;
use PhpParser\Node\Stmt\Return_;
use PhpParser\Node\Stmt\Use_;
use PhpParser\Node\Stmt\UseUse;
use PhpParser\Node\VarLikeIdentifier;
use PhpParser\NodeTraverser;
use PhpParser\NodeVisitorAbstract;
use PhpParser\ParserFactory;
use PhpParser\PrettyPrinter\Standard;

require 'vendor/autoload.php';

const OUTPUT_FILE = 'src/AutoMapper.php';

const COMPONENTS = [
    Api\Main::class,
    Api\Fields::class,
    Api\Processors::class,
    Api\Helpers::class,
    Integrations\RespectValidation\Api\Validation::class,
];

class Context
{
    private array $usings = [];
    private array $methods = [];

    public function addUsing(UseUse $use)
    {
        $this->usings[] = $use;
    }

    public function addMethod(string $className, ClassMethod $method)
    {
        if (!isset($this->methods[$className])) {
            $this->methods[$className] = [];
        }

        $this->methods[$className][] = $method;
    }

    /**
     * @return UseUse[]
     */
    public function getUsings(): array
    {
        return $this->usings;
    }

    /**
     * @return array<string, ClassMethod[]>
     */
    public function getMethods(): array
    {
        return $this->methods;
    }
}

$parserFactory = new ParserFactory();
$parser = $parserFactory->create(ParserFactory::ONLY_PHP7);
$context = new Context();

foreach (COMPONENTS as $class) {
    $implRef = new ReflectionClass($class);
    $sourceCode = file_get_contents($implRef->getFileName());
    $stmts = $parser->parse($sourceCode);

    $traverser = new NodeTraverser();
    $traverser->addVisitor(new class($class, $context) extends NodeVisitorAbstract {
        public function __construct(
            private string  $class,
            private Context $context
        )
        {
        }

        public function enterNode(Node $node)
        {
            if ($node instanceof GroupUse) {
                foreach ($node->uses as $use) {
                    $use->name->parts = [$node->prefix, ...$use->name->parts];
                    $this->context->addUsing($use);
                }
            }

            if ($node instanceof Use_) {
                foreach ($node->uses as $use) {
                    $this->context->addUsing($use);
                }
            }

            if ($node instanceof ClassMethod && $node->isPublic() && $node->name->name !== '__construct') {
                $this->context->addMethod($this->class, $node);
            }
        }
    });

    $traverser->traverse($stmts);
}

$result = [
    new Declare_([
        new DeclareDeclare('strict_types', new LNumber(1))
    ]),
    new Namespace_(new Name('Acelot\\AutoMapper')),
];

// Usings
$usings = [];

foreach (COMPONENTS as $class) {
    $usings[$class] = new UseUse(new Name($class));
}

foreach ($context->getUsings() as $use) {
    $key = $use->name->toCodeString();
    $usings[$key] = $use;
}

ksort($usings);

foreach ($usings as $using) {
    $result[] = new Use_([$using]);
}

// API class
$classNode = new Class_('AutoMapper');
$classNode->flags = Class_::MODIFIER_FINAL;
$classNode->setDocComment(new Doc(
    <<<'PHP'
    /**
     * @generated AUTOGENERATED FILE, DO NOT TOUCH, USE `make build` TO UPDATE
     */
    PHP
));
$classNode->stmts = [
    new Property(
        Class_::MODIFIER_PRIVATE | Class_::MODIFIER_STATIC,
        [
            new PropertyProperty(
                new VarLikeIdentifier('instances'),
                new Array_()
            )
        ],
        [],
        new Identifier('array')
    )
];

// APIs static methods
foreach (COMPONENTS as $class) {
    $implRef = new ReflectionClass($class);

    foreach ($context->getMethods()[$class] as $method) {
        $expr = new MethodCall(
            new StaticCall(
                new Name('self'),
                new Identifier('getInstance'),
                [
                    new Arg(
                        new ClassConstFetch(
                            new Name($implRef->getShortName()),
                            new Identifier('class')
                        )
                    )
                ]
            ),
            $method->name,
            array_map(function (Param $p) {
                return new Arg($p->var, false, $p->variadic);
            }, $method->params)
        );

        $method->flags = $method->flags | Class_::MODIFIER_STATIC;

        $method->stmts = [
            $method->returnType instanceof Identifier && $method->returnType->name === 'void'
                ? new Expression($expr)
                : new Return_($expr)
        ];

        $classNode->stmts[] = $method;
    }
}

// APIs instance getter
$classNode->stmts[] = new ClassMethod(
    new Identifier('getInstance'),
    [
        'flags' => Class_::MODIFIER_PRIVATE | Class_::MODIFIER_STATIC,
        'params' => [
            new Param(
                new Variable('class'),
                null,
                new Identifier('string')
            )
        ],
        'stmts' => [
            new If_(
                new BooleanNot(
                    new Isset_([
                        new ArrayDimFetch(
                            new StaticPropertyFetch(
                                new Name('self'),
                                new VarLikeIdentifier('instances')
                            ),
                            new Variable('class')
                        )
                    ])
                ),
                [
                    'stmts' => [
                        new Expression(
                            new Assign(
                                new ArrayDimFetch(
                                    new StaticPropertyFetch(
                                        new Name('self'),
                                        new VarLikeIdentifier('instances')
                                    ),
                                    new Variable('class')
                                ),
                                new New_(
                                    new Variable('class')
                                )
                            )
                        )
                    ]
                ]
            ),
            new Return_(
                new ArrayDimFetch(
                    new StaticPropertyFetch(
                        new Name('self'),
                        new VarLikeIdentifier('instances')
                    ),
                    new Variable('class')
                )
            )
        ],
    ],
    [
        'comments' => [
            new Doc(
                <<<'PHP'
                /**
                 * @template T
                 * @param class-string<T> $class
                 * @return T
                 */
                PHP
            )
        ],
    ]
);

$result[] = $classNode;

$out = fopen(OUTPUT_FILE, 'w');

try {
    $printer = new Standard();
    fwrite($out, '<?php ' . $printer->prettyPrint($result));
} finally {
    fclose($out);
}
